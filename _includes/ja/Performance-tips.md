- 全域(グローバル)変数は使用しないでください。
- [型安定](https://www.johnmyleswhite.com/notebook/2013/12/06/writing-type-stable-code-in-julia)なコードを書きましょう。
- 可能な限り，イミュータブル(不変, 変更不能)な型を使いましょう。
- 大きな配列には`sizehint`を使います。
- 大きな配列は，`arr=nothing` を使ってメモリを解放しましょう。
- 配列は列(第1の軸)に沿ってアクセスしましょう。多次元配列は column-major の順序で格納されるからです。
- 結果を格納するデータ構造は，事前に割り当てておきましょう。
- リアルタイムなアプリケーションでは，ガベージコレクタを無効にします:`disable_gc()`。
- キーワード引数にsplat (`...`) 演算子を使用しないでください。
- 更新 (mutating) API (名前に `!`がつく関数) を使いましょう。データ構造のコピーを回避できます。
- リストの内包表記よりも，配列 (要素毎の)演算を使いましょう。
- (計算が集中して行われる)繰返し(ループ)では，`try`-`catch` を使用しないでください。
- コレクション内では `Any` を避けましょう。
- コレクション内では，抽象(アブストラクト)型を避けましょう。
- 入出力では，文字列の補間を避けましょう。
- ベクトル化 ([Vectorizing](https://www.johnmyleswhite.com/notebook/2013/12/22/the-relationship-between-vectorized-and-devectorized-code "https://www.johnmyleswhite.com/notebook/2013/12/22/the-relationship-between-vectorized-and-devectorized-code"))は，速度を向上させません (R，MATLAB，Pythonとは異なります)。
- 実行時は `eval` の使用を避けましょう。
